import { UntypedFormControl, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { BoxedValue } from './types';
export declare class FormControl<T> extends UntypedFormControl {
    readonly value: T;
    readonly valueChanges: Observable<T>;
    private touchChanges;
    private dirtyChanges;
    private errorsSubject;
    readonly touch$: Observable<boolean>;
    readonly dirty$: Observable<boolean>;
    readonly value$: Observable<T>;
    readonly disabled$: Observable<boolean>;
    readonly enabled$: Observable<boolean>;
    readonly invalid$: Observable<boolean>;
    readonly valid$: Observable<boolean>;
    readonly status$: Observable<import("./core").ControlState>;
    readonly errors$: Observable<ValidationErrors | null>;
    constructor(formState?: BoxedValue<T>, validatorOrOpts?: ConstructorParameters<typeof UntypedFormControl>[1], asyncValidator?: ConstructorParameters<typeof UntypedFormControl>[2]);
    setValue(valueOrObservable: Observable<T>, options?: Parameters<AbstractControl['setValue']>[1]): Subscription;
    setValue(valueOrObservable: T, options?: Parameters<AbstractControl['setValue']>[1]): void;
    patchValue(valueOrObservable: Observable<T>, options?: Parameters<AbstractControl['patchValue']>[1]): Subscription;
    patchValue(valueOrObservable: T, options?: Parameters<AbstractControl['patchValue']>[1]): void;
    getRawValue(): T;
    markAsTouched(...opts: Parameters<AbstractControl['markAsTouched']>): ReturnType<AbstractControl['markAsTouched']>;
    markAsUntouched(...opts: Parameters<AbstractControl['markAsUntouched']>): ReturnType<AbstractControl['markAsUntouched']>;
    markAsPristine(...opts: Parameters<AbstractControl['markAsPristine']>): ReturnType<AbstractControl['markAsPristine']>;
    markAsDirty(...opts: Parameters<AbstractControl['markAsDirty']>): ReturnType<AbstractControl['markAsDirty']>;
    setEnable(enable?: boolean, opts?: Parameters<AbstractControl['enable']>[0]): void;
    setDisable(disable?: boolean, opts?: Parameters<AbstractControl['disable']>[0]): void;
    disabledWhile(observable: Observable<boolean>, options?: Parameters<AbstractControl['disable']>[0]): Subscription;
    enabledWhile(observable: Observable<boolean>, options?: Parameters<AbstractControl['enable']>[0]): Subscription;
    reset(formState?: T, options?: Parameters<AbstractControl['reset']>[1]): void;
    setValidators(newValidators: Parameters<AbstractControl['setValidators']>[0], options?: Parameters<AbstractControl['updateValueAndValidity']>[0]): void;
    setAsyncValidators(newValidator: Parameters<AbstractControl['setAsyncValidators']>[0], options?: Parameters<AbstractControl['updateValueAndValidity']>[0]): void;
    getError<E>(...params: Parameters<AbstractControl['getError']>): E | null;
    setErrors(...opts: Parameters<AbstractControl['setErrors']>): void;
    mergeErrors(errors: ValidationErrors | null, opts?: Parameters<AbstractControl['setErrors']>[1]): void;
    removeError(key: string, opts?: Parameters<AbstractControl['setErrors']>[1]): void;
    hasErrorAndTouched(error: string): boolean;
    hasErrorAndDirty(error: string): boolean;
}
