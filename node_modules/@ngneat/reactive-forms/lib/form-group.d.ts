import { AbstractControl, UntypedFormGroup, ValidationErrors } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { DeepPartial, ValuesOf } from './types';
export declare class FormGroup<T extends Record<string, any>> extends UntypedFormGroup {
    controls: T;
    readonly value: ValuesOf<T>;
    readonly valueChanges: Observable<ValuesOf<T>>;
    private touchChanges;
    private dirtyChanges;
    private errorsSubject;
    readonly touch$: Observable<boolean>;
    readonly dirty$: Observable<boolean>;
    readonly value$: Observable<ValuesOf<T>>;
    readonly disabled$: Observable<boolean>;
    readonly enabled$: Observable<boolean>;
    readonly invalid$: Observable<boolean>;
    readonly valid$: Observable<boolean>;
    readonly status$: Observable<import("./core").ControlState>;
    readonly errors$: Observable<ValidationErrors | null>;
    constructor(controls: T, validatorOrOpts?: ConstructorParameters<typeof UntypedFormGroup>[1], asyncValidator?: ConstructorParameters<typeof UntypedFormGroup>[2]);
    select<R>(mapFn: (state: ValuesOf<T>) => R): Observable<R>;
    get<K extends keyof ValuesOf<T>, K1 extends keyof ValuesOf<T>[K], K2 extends keyof ValuesOf<T>[K][K1], FirstLevel = GroupPath<T[K], K1 & string>, SecondLevel = GroupPath<FirstLevel, K2 & string>>(keys: [K, K1, K2]): SecondLevel;
    get<K extends keyof ValuesOf<T>, K1 extends keyof ValuesOf<T>[K]>(keys: [K, K1]): GroupPath<T[K], K1 & string>;
    get<K extends keyof ValuesOf<T>>(keys: [K]): T[K];
    get<K extends string, P = K extends `${infer Key}.${infer Rest}` ? unknown : K>(key: K): unknown extends P ? AbstractControl : T[K];
    setValue(valueOrObservable: Observable<ValuesOf<T>>, options?: Parameters<AbstractControl['setValue']>[1]): Subscription;
    setValue(valueOrObservable: ValuesOf<T>, options?: Parameters<AbstractControl['setValue']>[1]): void;
    patchValue(valueOrObservable: Observable<DeepPartial<ValuesOf<T>>>, options?: Parameters<AbstractControl['patchValue']>[1]): Subscription;
    patchValue(valueOrObservable: DeepPartial<ValuesOf<T>>, options?: Parameters<AbstractControl['patchValue']>[1]): void;
    getRawValue(): ValuesOf<T>;
    markAsTouched(...opts: Parameters<AbstractControl['markAsTouched']>): ReturnType<AbstractControl['markAsTouched']>;
    markAsUntouched(...opts: Parameters<AbstractControl['markAsUntouched']>): ReturnType<AbstractControl['markAsUntouched']>;
    markAsPristine(...opts: Parameters<AbstractControl['markAsPristine']>): ReturnType<AbstractControl['markAsPristine']>;
    markAsDirty(...opts: Parameters<AbstractControl['markAsDirty']>): ReturnType<AbstractControl['markAsDirty']>;
    markAllAsDirty(): void;
    setEnable(enable?: boolean, opts?: Parameters<AbstractControl['enable']>[0]): void;
    setDisable(disable?: boolean, opts?: Parameters<AbstractControl['disable']>[0]): void;
    disabledWhile(observable: Observable<boolean>, options?: Parameters<AbstractControl['disable']>[0]): Subscription;
    enabledWhile(observable: Observable<boolean>, options?: Parameters<AbstractControl['enable']>[0]): Subscription;
    reset(formState?: ValuesOf<T>, options?: Parameters<AbstractControl['reset']>[1]): void;
    setValidators(newValidators: Parameters<AbstractControl['setValidators']>[0], options?: Parameters<AbstractControl['updateValueAndValidity']>[0]): void;
    setAsyncValidators(newValidator: Parameters<AbstractControl['setAsyncValidators']>[0], options?: Parameters<AbstractControl['updateValueAndValidity']>[0]): void;
    getError<E>(...params: Parameters<AbstractControl['getError']>): E | null;
    setErrors(...opts: Parameters<AbstractControl['setErrors']>): void;
    mergeErrors(errors: ValidationErrors | null, opts?: Parameters<AbstractControl['setErrors']>[1]): void;
    removeError(key: string, opts?: Parameters<AbstractControl['setErrors']>[1]): void;
    hasErrorAndTouched(error: string, path?: Parameters<AbstractControl['hasError']>[1]): boolean;
    hasErrorAndDirty(error: string, path?: Parameters<AbstractControl['hasError']>[1]): boolean;
}
declare type GroupPath<T, K extends string> = T extends FormGroup<infer U> ? U[K & string] : never;
export {};
