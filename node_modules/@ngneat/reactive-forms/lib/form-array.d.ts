import { AbstractControl, UntypedFormArray, ValidationErrors } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { ControlsOf, FormControl, FormGroup, ValuesOf } from '..';
import { DeepPartial } from './types';
declare type ValueOfControl<T> = T extends FormControl<infer C> ? C : T extends FormGroup<infer C> ? ValuesOf<C> : never;
export declare class FormArray<T, Control extends AbstractControl = T extends Record<any, any> ? FormGroup<ControlsOf<T>> : FormControl<T>> extends UntypedFormArray {
    controls: Array<Control>;
    readonly value: ValueOfControl<Control>[];
    readonly valueChanges: Observable<ValueOfControl<Control>[]>;
    private touchChanges;
    private dirtyChanges;
    private errorsSubject;
    readonly touch$: Observable<boolean>;
    readonly dirty$: Observable<boolean>;
    readonly value$: Observable<ValueOfControl<Control>[]>;
    readonly disabled$: Observable<boolean>;
    readonly enabled$: Observable<boolean>;
    readonly invalid$: Observable<boolean>;
    readonly valid$: Observable<boolean>;
    readonly status$: Observable<import("./core").ControlState>;
    readonly errors$: Observable<ValidationErrors | null>;
    constructor(controls: Array<Control>, validatorOrOpts?: ConstructorParameters<typeof UntypedFormArray>[1], asyncValidator?: ConstructorParameters<typeof UntypedFormArray>[2]);
    select<R>(mapFn: (state: ValueOfControl<Control>[]) => R): Observable<R>;
    setValue(valueOrObservable: Observable<ValueOfControl<Control>[]>, options?: Parameters<UntypedFormArray['setValue']>[1]): Subscription;
    setValue(valueOrObservable: ValueOfControl<Control>[], options?: Parameters<UntypedFormArray['setValue']>[1]): void;
    patchValue(valueOrObservable: Observable<DeepPartial<ValueOfControl<Control>>[]>, options?: Parameters<UntypedFormArray['patchValue']>[1]): Subscription;
    patchValue(valueOrObservable: DeepPartial<ValueOfControl<Control>>[], options?: Parameters<UntypedFormArray['patchValue']>[1]): void;
    getRawValue(): ValueOfControl<Control>[];
    push(control: Control, options?: Parameters<UntypedFormArray['push']>[1]): void;
    insert(index: number, control: Control, options?: Parameters<UntypedFormArray['insert']>[2]): void;
    setControl(index: number, control: Control, options?: Parameters<UntypedFormArray['setControl']>[2]): void;
    at(index: number): Control;
    remove(value: ValueOfControl<Control>, options?: Parameters<UntypedFormArray['removeAt']>[1]): void;
    removeWhen(predicate: (element: Control) => boolean, options?: Parameters<UntypedFormArray['removeAt']>[1]): void;
    markAsTouched(...opts: Parameters<UntypedFormArray['markAsTouched']>): ReturnType<UntypedFormArray['markAsTouched']>;
    markAsUntouched(...opts: Parameters<UntypedFormArray['markAsUntouched']>): ReturnType<UntypedFormArray['markAsUntouched']>;
    markAsPristine(...opts: Parameters<UntypedFormArray['markAsPristine']>): ReturnType<UntypedFormArray['markAsPristine']>;
    markAsDirty(...opts: Parameters<UntypedFormArray['markAsDirty']>): ReturnType<UntypedFormArray['markAsDirty']>;
    markAllAsDirty(): void;
    setEnable(enable?: boolean, opts?: Parameters<UntypedFormArray['enable']>[0]): void;
    setDisable(disable?: boolean, opts?: Parameters<UntypedFormArray['disable']>[0]): void;
    disabledWhile(observable: Observable<boolean>, options?: Parameters<UntypedFormArray['disable']>[0]): Subscription;
    enabledWhile(observable: Observable<boolean>, options?: Parameters<UntypedFormArray['enable']>[0]): Subscription;
    reset(formState?: ValueOfControl<Control>[], options?: Parameters<UntypedFormArray['reset']>[1]): void;
    setValidators(newValidators: Parameters<UntypedFormArray['setValidators']>[0], options?: Parameters<UntypedFormArray['updateValueAndValidity']>[0]): void;
    setAsyncValidators(newValidator: Parameters<UntypedFormArray['setAsyncValidators']>[0], options?: Parameters<UntypedFormArray['updateValueAndValidity']>[0]): void;
    getError<E>(...params: Parameters<UntypedFormArray['getError']>): E | null;
    setErrors(...opts: Parameters<UntypedFormArray['setErrors']>): void;
    mergeErrors(errors: ValidationErrors | null, opts?: Parameters<UntypedFormArray['setErrors']>[1]): void;
    removeError(key: string, opts?: Parameters<UntypedFormArray['setErrors']>[1]): void;
    hasErrorAndTouched(error: string, path?: Parameters<UntypedFormArray['hasError']>[1]): boolean;
    hasErrorAndDirty(error: string, path?: Parameters<UntypedFormArray['hasError']>[1]): boolean;
}
export {};
